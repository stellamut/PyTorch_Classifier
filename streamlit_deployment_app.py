# -*- coding: utf-8 -*-
"""Streamlit Deployment App

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KRN2tKkyiZwN5G0-uRRQPXjVhTgfyoXR
"""

import streamlit as st
import torch
import torch.nn as nn
from torchvision import transforms
from PIL import Image
import io
import numpy as np

# --- 1. Model Definition (MUST be identical to the training script) ---
class Net(nn.Module):
    def __init__(self):
        super(Net, self).__init__()
        # 1. First Convolutional Layer
        self.conv1 = nn.Conv2d(1, 32, kernel_size=3)
        # 2. Second Convolutional Layer
        self.conv2 = nn.Conv2d(32, 64, kernel_size=3)

        self.pool = nn.MaxPool2d(2)
        self.dropout1 = nn.Dropout(0.25)
        self.dropout2 = nn.Dropout(0.5)

        # Flattened size: 5 * 5 * 64 = 1600
        self.fc1 = nn.Linear(5 * 5 * 64, 128)
        self.fc2 = nn.Linear(128, 10)

    def forward(self, x):
        x = self.conv1(x)
        x = nn.functional.relu(x)
        x = self.pool(x)
        x = self.dropout1(x)

        x = self.conv2(x)
        x = nn.functional.relu(x)
        x = self.pool(x)
        x = self.dropout2(x)

        x = x.view(-1, 5 * 5 * 64)

        x = self.fc1(x)
        x = nn.functional.relu(x)

        x = self.fc2(x)
        return x

# --- 2. Model Loading Function ---
@st.cache_resource # Cache the model so it loads only once
def load_model(model_path):
    """Initializes the model and loads the weights."""
    # Use CPU since Streamlit apps usually run on CPU
    device = torch.device('cpu')
    model = Net().to(device)
    try:
        # Load the state_dict from the saved file
        model.load_state_dict(torch.load(model_path, map_location=device))
        model.eval() # Set to evaluation mode
        st.success("Model loaded successfully!")
        return model
    except FileNotFoundError:
        st.error(f"Model file '{model_path}' not found. Please run the training script first.")
        return None
    except Exception as e:
        st.error(f"Error loading model: {e}")
        return None

# --- 3. Preprocessing Transformations (MUST match training) ---
# MNIST images need to be resized to 28x28, converted to grayscale,
# converted to a PyTorch tensor, and normalized.
data_transform = transforms.Compose([
    transforms.Resize((28, 28)),          # Resize uploaded image to 28x28
    transforms.Grayscale(num_output_channels=1), # Ensure it's 1 channel
    transforms.ToTensor(),                # Convert to tensor
    transforms.Normalize((0.1307,), (0.3081,)) # Apply same normalization as training
])


# --- 4. Streamlit Application UI and Logic ---
def main():
    st.set_page_config(
        page_title="MNIST Digit Classifier",
        layout="centered",
        initial_sidebar_state="auto"
    )
    st.title("PyTorch MNIST CNN Digit Classifier")
    st.markdown("Upload a grayscale image of a handwritten digit (0-9) to get a prediction.")

    # Load the model
    model = load_model('mnist_cnn_model.pth')

    if model is None:
        return

    # File Uploader
    uploaded_file = st.file_uploader(
        "Choose an image...",
        type=['png', 'jpg', 'jpeg'],
        help="Recommended to use an image with a dark background and light digit, similar to MNIST."
    )

    if uploaded_file is not None:
        # Display the uploaded image
        image = Image.open(uploaded_file)
        st.image(image, caption='Uploaded Digit Image', width=200)

        st.subheader("Prediction:")

        # Preprocess the image for the model
        input_tensor = data_transform(image)
        # Add a batch dimension: [C, H, W] -> [1, C, H, W]
        input_batch = input_tensor.unsqueeze(0)

        # Make prediction
        with torch.no_grad():
            output = model(input_batch)

        # Get probabilities and predicted class
        probabilities = nn.functional.softmax(output, dim=1)[0]
        predicted_class = torch.argmax(probabilities).item()
        confidence = probabilities[predicted_class].item() * 100

        # Display results
        st.success(f"The model predicts the digit is: **{predicted_class}**")
        st.info(f"Confidence: {confidence:.2f}%")

        # Display full probability distribution
        st.markdown("---")
        st.subheader("Probability Distribution")

        # Create a dictionary for the bar chart
        labels = [str(i) for i in range(10)]
        data = probabilities.cpu().numpy()

        df_probabilities = {
            'Digit': labels,
            'Probability': data
        }

        st.bar_chart(df_probabilities, x='Digit', y='Probability', color="#f63366")

if __name__ == '__main__':
    main()